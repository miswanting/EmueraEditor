;[ライセンス]パブリックドメイン
;本ファイルに係る著作権を放棄する。
;本ファイルに係る著作人格権は行使しない。
;2015/11/01 MinorShift(Emuera作者)

;独自のBEGINシステムの例（Emuera  ver 1.821以降対象）
;既存スクリプトのうち、「BEGIN HOGE」を「BEGINWORD = HOGE」「RETURN」で置き換えてください。
;またLOADGAMEの代わりにCALL LOADGAME_EX、SAVEGAMEの代わりにCALL SAVEGAME_EXを実行してください。

;DOTRAIN及びCALLTRAIN命令は使用できません。
;NEXTCOMは無視されます。
;また、ITEMやMONEYなどの変数が使用禁止されているとエラーになります。

;使用している命令の詳細については下記のEmueraWikiを参照してください。
;http://osdn.jp/projects/emuera/wiki/FrontPage



;@SYSTEM_TITLEが定義されていると、標準のタイトル画面の代わりにSYSTEM_TITLEが呼ばれる。
@SYSTEM_TITLE
#DIMS VERSIONNAME
;このタイミングでグローバル変数を読んでおけば取りこぼしが無くなる。
;GLOBALはRESETDATAやLOADDATAによって初期化・上書きされない。
;必要に応じてコメントアウトを解除すること。
;LOADGLOBAL

;バージョン表記をVERSIONNAMEに作成。
;1001なら1.001、1100なら1.10と表示される
VERSIONNAME = {GAMEBASE_VERSION / 1000}.%TOSTR(GAMEBASE_VERSION % 1000 / 10,"00")%
SIF GAMEBASE_VERSION % 10 != 0
	VERSIONNAME += TOSTR(GAMEBASE_VERSION % 10)

;タイトル表示。
DRAWLINE 

ALIGNMENT CENTER
PRINTFORML %GAMEBASE_TITLE%
PRINTFORML %VERSIONNAME%
PRINTFORML %GAMEBASE_AUTHOR%
PRINTFORML (%GAMEBASE_YEAR%)
PRINTL 
PRINTFORML %GAMEBASE_INFO%
ALIGNMENT LEFT

DRAWLINE 

;選択肢表示
$TITLE_SELECT
PRINTSL "[0] " + GETCONFIGS("システムメニュー0");
PRINTSL "[1] " + GETCONFIGS("システムメニュー1");

$TITLE_INPUT
INPUT
IF RESULT == 0
	RESETDATA
	;ADDDEFCHARAはeramakerの初期化処理を再現するために存在する専用の関数です
	;他の場面ではADDCHARAを使用してください
	ADDDEFCHARA
	BEGINWORD '= "FIRST"
	CALL MAIN_LOOP
ELSEIF RESULT == 1
	CALL LOADGAME_EX
	GOTO TITLE_SELECT
	;LOADGAME_EXでLOADを行わずに戻ってきた場合、もう一度選択しなおす。
ELSE
	REUSELASTLINE 無効な値です
	GOTO TITLE_INPUT
ENDIF


@SYSTEM_LOADEND
;@SYSTEM_LOADENDが定義されていると、ロード直後にSYSTEM_LOADENDが呼ばれる。（EVENTLOAD呼び出しより前）
BEGINWORD '= "LOADEND"
CALL MAIN_LOOP

@MAIN_LOOP
WHILE 1
	SELECTCASE BEGINWORD
	CASE "FIRST"
		BEGINWORD '= "ERROR"
		CALLEVENT EVENTFIRST
	CASE "AFTERTRAIN"
		BEGINWORD '= "ERROR"
		CALLEVENT EVENTEND
	CASE "TURNEND"
		BEGINWORD '= "ERROR"
		CALLEVENT EVENTTURNEND
	CASE "ABLUP"
		CALL BEGIN_ABLUP
	CASE "SHOP"
		CALL BEGIN_SHOP
	CASE "LOADEND"
		CALLEVENT EVENTLOAD
		IF BEGINWORD == "LOADEND"
			BEGINWORD '= "SHOP"
			CALL SHOP_LOOP
		ENDIF
	CASE "TRAIN"
		CALL BEGIN_TRAIN
	CASE "TITLE"
		BEGIN TITLE
	CASE "ERROR"
		THROW 次に実行すべき処理がない
	CASEELSE
		THROW BEGINWORD ERROR:"%BEGINWORD%"は解釈不能
	ENDSELECT
WEND


@BEGIN_ABLUP
WHILE 1
	IF BEGINWORD != "ABLUP"
		RETURN
	ENDIF
	CALL SHOW_JUEL
	CALL SHOW_ABLUP_SELECT
	INPUT
	IF RESULT < 0 || RESULT >= 100
		CALL USERABLUP
		CONTINUE
	ENDIF
	TRYCALLFORM ABLUP{RESULT}
WEND


@BEGIN_SHOP
CALLEVENT EVENTSHOP
IF GETCONFIG("オートセーブを行なう")
	TRYCALL SYSTEM_AUTOSAVE
ENDIF
CALL SHOP_LOOP

@SHOP_LOOP
WHILE 1
	IF BEGINWORD != "SHOP"
		RETURN
	ENDIF
	CALL SHOW_SHOP
	$INPUT_LOOP
	INPUT
	;0-99以外ならUSERSHOP後、SHOW_SHOPやりなおし
	IF RESULT < 0 || RESULT >= 100
		CALL USERSHOP
		CONTINUE
	ENDIF
	;購入を試みる
	IF !ITEMSALES:RESULT || ITEMPRICE:RESULT > MONEY
		;eramaker式ならRESTART
		GOTO INPUT_LOOP
	ENDIF
	BOUGHT = RESULT
	MONEY -= ITEMPRICE:BOUGHT
	ITEM:BOUGHT += 1
	CALLEVENT EVENTBUY
WEND

@BEGIN_TRAIN
CALL CLEARDATA_BEGINTRAIN
CALLEVENT EVENTTRAIN
CALL TRAIN_LOOP

@TRAIN_LOOP
#DIM LCOUNT
#DIM COMABLEARRAY,VARSIZE("TRAINNAME")
#DIM ABLECOUNT
#DIM TRAINCOUNT
#DIM RESCOM
#DIM INPUT_RESULT

WHILE 1
	IF BEGINWORD != "TRAIN"
		RETURN
	ENDIF
	CALL SHOW_STATUS

	;COM_ABLE探査＆コマンド表示処理
	VARSET COMABLEARRAY
	ABLECOUNT = 0
	TRAINCOUNT = 0
	;実行可能コマンドをボタン化してPRINT
	FOR LCOUNT,0,VARSIZE("TRAINNAME")
		IF TRAINNAME:LCOUNT == ""
			CONTINUE
		ENDIF
		RESULT = GETCONFIG("COM_ABLE初期値")
		TRYCALLFORM COM_ABLE{LCOUNT}
		IF RESULT ;実行可能
			PRINTBUTTONC @"%TRAINNAME:LCOUNT%[{TRAINCOUNT,3}]",TRAINCOUNT
			COMABLEARRAY:TRAINCOUNT = LCOUNT + 1 ;0を実行不可扱いにするため+1しておく
			ABLECOUNT++
			IF (ABLECOUNT % GETCONFIG("PRINTCを並べる数") == 0)
				PRINTL 
			ENDIF
		ENDIF
		TRAINCOUNT++
	NEXT
	IF !LINEISEMPTY()
		PRINTL 
	ENDIF
	CALL SHOW_USERCOM
	CALL CLEARDATA_SHOW_USERCOM

	INPUT
	INPUT_RESULT = RESULT
	CALL CLEARDATA_TRAININPUT
	RESCOM = -1
	IF INPUT_RESULT >= 0 || INPUT_RESULT < TRAINCOUNT
		RESCOM = COMABLEARRAY:INPUT_RESULT - 1
	ENDIF
	IF RESCOM < 0
		;入力をRESULTで渡してUSERCOMへ
		RESULT = INPUT_RESULT
		CALL USERCOM
		CONTINUE
	ENDIF

	SELECTCOM = RESCOM
	CALLEVENT EVENTCOM
	CALLFORM COM{SELECTCOM}
	;実行に成功した
	IF RESULT
		CALL SOURCE_CHECK
		CALL CLEARDATA_SOURCECHECK
		;本来のeramakerには、EVENTCOMEND内でWAITが存在しなければWAITを追加する処理がある
		CALLEVENT EVENTCOMEND
	ENDIF
WEND

;TRAIN中のデータクリア処理群
;タイミングは一応eramakerを再現している
;TARGET,ASSI,MASTERにとどまらず全キャラのキャラ変数をリセットしていくのもeramaker同様
@CLEARDATA_BEGINTRAIN
#DIM LCOUNT
ASSIPLAY = 0;
PREVCOM = -1;
;NEXTCOM = -1;
VARSET TFLAG
VARSET TSTR
FOR LCOUNT,0,CHARANUM
	VARSET GOTJUEL:LCOUNT:0
	VARSET TEQUIP:LCOUNT:0
	VARSET EX:LCOUNT:0
	RESET_STAIN LCOUNT
	VARSET PALAM:LCOUNT:0
	VARSET SOURCE:LCOUNT:0
	VARSET TCVAR:LCOUNT:0
NEXT

@CLEARDATA_SHOW_USERCOM
#DIM LCOUNT
VARSET LOSEBASE
VARSET UP
VARSET DOWN
FOR LCOUNT,0,CHARANUM
	VARSET DOWNBASE:LCOUNT:0
	VARSET CUP:LCOUNT:0
	VARSET CDOWN:LCOUNT:0
NEXT

@CLEARDATA_TRAININPUT
#DIM LCOUNT
FOR LCOUNT,0,CHARANUM
	VARSET NOWEX:LCOUNT:0
NEXT

@CLEARDATA_SOURCECHECK
#DIM LCOUNT
FOR LCOUNT,0,CHARANUM
	VARSET SOURCE:LCOUNT:0
NEXT


@SAVEGAME_EX
#DIM PAGE_NUM ;何ページ目を表示しているか
#DIM DATANUM;RESULT一時記録用
PAGE_NUM = 0

$REDRAW_SAVEDATA
REDRAW 0
PRINTL 何番にセーブしますか？
CALL PRINT_SAVEDATA, PAGE_NUM
PRINTL [100] 戻る
REDRAW 1
$INPUT_DATANUM
INPUT
IF (RESULT == 100)
	RETURN
ELSEIF ((RESULT < 0) || (RESULT >= SAVENOS()))
	
ELSEIF ((RESULT >= PAGE_NUM * 20) && (RESULT < PAGE_NUM * 20 + 20))
	DATANUM = RESULT
	CHKDATA DATANUM
	;RESULT == 1は"ファイルが存在しない"
	IF RESULT != 1
		PRINTL 既にデータが存在します。上書きしますか？
		PRINTL [0] はい
		PRINTL [1] いいえ
$YESNO_INPUT_LOOP
		INPUT
		IF RESULT == 1
			GOTO REDRAW_SAVEDATA
		ELSEIF RESULT != 0
			GOTO YESNO_INPUT_LOOP
		ENDIF
	ENDIF
	CALL SAVEINFO_EX
	SAVEDATA DATANUM, RESULTS
	RETURN
ELSEIF (RESULT%20 == 0)
	PAGE_NUM = RESULT/20
	GOTO REDRAW_SAVEDATA
ENDIF
CLEARLINE 1
REUSELASTLINE 無効な値です
WAIT
GOTO INPUT_DATANUM

@LOADGAME_EX
#DIM PAGE_NUM ;何ページ目を表示しているか
#DIM DATANUM;RESULT一時記録用
PAGE_NUM = 0

$REDRAW_SAVEDATA
REDRAW 0
PRINTL 何番をロードしますか？
CALL PRINT_SAVEDATA, PAGE_NUM
CHKDATA 99
PRINTFORML [99] %RESULTS:0%
PRINTL [100] 戻る
REDRAW 1
$INPUT_DATANUM
INPUT
IF (RESULT == 100)
	RETURN
ELSEIF ((RESULT < 0) || (RESULT >= SAVENOS())) && (RESULT != 99)

ELSEIF ((RESULT >= PAGE_NUM * 20) && (RESULT < PAGE_NUM * 20 + 20)) || (RESULT == 99)
	DATANUM = RESULT
	CHKDATA DATANUM
	;RESULT == 0ならロード可能
	IF RESULT != 0
		PRINTL データがありません
		GOTO REDRAW_SAVEDATA
	ENDIF
	LOADDATA DATANUM
	RETURN
ELSEIF (RESULT%20 == 0)
	PAGE_NUM = RESULT/20
	GOTO REDRAW_SAVEDATA
ENDIF
CLEARLINE 1
REUSELASTLINE 無効な値です
WAIT
GOTO INPUT_DATANUM

@PRINT_SAVEDATA(PAGE_NUM)
#DIM PAGE_NUM
#DIM LCOUNT
;PAGE_NUM 何ページ目を表示しているか
IF PAGE_NUM > 0
	FOR LCOUNT, 0, PAGE_NUM
		PRINTFORML [{LCOUNT*20, 2}] セーブデータ{LCOUNT*20, 2}〜{LCOUNT*20+19, 2}を表示
	NEXT
ENDIF
FOR LCOUNT, PAGE_NUM * 20, PAGE_NUM * 20 + 20
	IF (LCOUNT >= SAVENOS())
		BREAK
	ENDIF
	CHKDATA LCOUNT
	PRINTFORML [{LCOUNT, 2, RIGHT}] %RESULTS:0%
NEXT
IF (PAGE_NUM + 1) < (SAVENOS() + 19 / 20)
	FOR LCOUNT, PAGE_NUM + 1, (SAVENOS() + 19) / 20
		PRINTFORML [{LCOUNT*20, 2}] セーブデータ{LCOUNT*20, 2}〜{MIN(LCOUNT*20+19, SAVENOS() - 1), 2}を表示
	NEXT
ENDIF
RETURN

@SAVEINFO_EX
;SAVEDATA命令は@SAVEINFO関数を呼ばないのでPUTFORMの代わりの文字列を用意する必要がある
;GETTIME関数でRESULTSに現在時刻を表す文字列を代入
RESULTS '= GETTIMES()
IF TIME == 0
	RESULTS += " " + TOSTR(DAY+1) + "日目午前"
ELSE
	RESULTS += " " + TOSTR(DAY+1) + "日目午後"
ENDIF
IF TARGET >= 0 && TARGET < CHARANUM
	RESULTS += " " + NAME:TARGET + @"調教中(従{ABL:0}欲{ABL:1}技{ABL:2})"
ENDIF
IF ASSI >= 0 && ASSI < CHARANUM
	RESULTS += " 助手：" + NAME:ASSI
ENDIF
RETURN

@SYSTEM_AUTOSAVE
CALL SAVEINFO_EX
SAVEDATA 99, RESULTS
